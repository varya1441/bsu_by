<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML>
<HEAD>
<TITLE>1.htm</TITLE>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=WINDOWS-1251">
<style>
.title_1{
	text-align: left;
	font-family: Arial, sans-serif;
	font-size: 20px;
	font-weight: normal;
}
.title_2{
	text-align: left;
	font-family: Arial,  sans-serif;
	font-size: 18px;
	font-weight: normal;
}

.title_3{
	text-align: left;
	font-family: Arial, sans-serif;
	font-size: 16px;
	font-weight: normal;
}
.text   {
	font-family:  Arial, sans-serif;
	font-size: 14px;
	font-weight: normal;
}
.text_b{
	font-family:  Arial, sans-serif;
	font-size: 14px;
    font-weight: bold;
}
.text_i{
	font-family:  Arial, sans-serif;
	font-size: 14px;
    font-style: italic;
}

.pic {
    font-family:  Arial, sans-serif; 
	font-size: 12px;
	font-weight: bold;
	text-align: left;
	font-style: italic;
}
.pic_i {
	font-family:  Arial, sans-serif; 
	font-size: 12px;
	font-style: italic;	
	text-align: left;
	font-weight: lighter;
}

.note {
	font-family:  Arial, sans-serif;
	font-size: 14px;
    font-style: italic;
}
.listing {
	font-family:  "Courier New", sans-serif;
	font-size: 12px;
	font-weight: normal;
}
li {
	font-family:  Arial, sans-serif;
	font-size: 14px;
	font-style: normal;
	font-variant: normal;
	line-height: normal;
	}
.menu {
	font-family:  Arial, sans-serif;
	font-size: 14px;
	font-weight: bold;
	padding-left : 15px;
}
.small {
	font-family:  Arial, sans-serif;
	font-size: 10px;
}
.small_b {
	font-family:  Arial, sans-serif;
	font-size: 10px;
	font-weight: bold;
}
</style>
</HEAD>

<body   BGCOLOR="#BED0F4" class="Text">
<table width="100%" border="0" class="Text">
  <tr> 
    <td align="left"> <p class="title_1">Преобразование чисел</p>
      <ul class="menu">
        <li><a href="#1"> Ввод чисел с консоли
            </a>
          <ul>
            <li><a href="#2"> Ввод целых десятичных чисел из диапазона 0..99</a></li>
            <li><a href="#3"> Ввод целых десятичных чисел из диапазона 0..4 294 967 295</a></li>
            <li><a href="#4"> Ввод целых десятичных чисел из диапазона 0..999 999 999 999 999 999 </a></li>
            <li><a href="#5"> Ввод целых десятичных чисел из диапазона 0..оо</a></li>
            <li><a href="#6"> Ввод вещественных чисел</a></li>
          </ul>
        </li>
        <li><a href="#7"> Вывод чисел на консоль
            </a>
          <ul>
            <li><a href="#8"> Вывод шестнадцатеричных чисел</a></li>
            <li><a href="#9"> Вывод целых десятичных чисел из диапазона 0..99</a></li>
            <li><a href="#10"> Вывод целых десятичных чисел из диапазона 0..оо</a></li>
            <li><a href="#11"> Вывод целых десятичных чисел из диапазона 0..999 999 999 999 999 999</a></li>
            <li><a href="#12"> Вывод вещественных чисел</a></li>
          </ul>
        </li>
      </ul>      
  <p align="right" class="listing"> Внутри каждой большой задачи сидит маленькая, <br>
  пытающаяся пробиться наружу. <br>
  Закон больших чисел Хоара (Прикладная Мерфология)</p>
      <p> В предыдущей главе мы рассмотрели решение проблемы обмена данными с консолью. Данные, вводимые с консоли и выводимые на нее, кодируются операционной системой в соответствии с текущей таблицей кодировки. Отдельный предмет обсуждения при этом — процесс ввода-вывода числовой информации. В каждом языке программирования он реализован по-своему. Одна из целей, к которой стремятся разработчики компиляторов, — по возможности сделать этот процесс прозрачным для программиста. Язык ассемблера в отличие от языков высокого уровня не обладает средствами такого прозрачного ввода-вывода числовой информации. Но в этом и состоит его достоинство, так как при определенном опыте и квалификации программиста появляется хорошая возможность повышения эффективности конечного кода.<br>
  Для каждой конкретной задачи преобразование чисел между различными представлениями, допустимыми компьютером, может быть выполнено несколькими способами. Для эффективного решения задач обработки числовой информации программист должен знать эти способы и уметь выбрать наиболее подходящий из них для решения конкретной проблемы. Сразу следует отметить, что эта тема далеко не нова. Многие источники, посвященные ассемблеру, с той или иной степенью подробности рассматривают проблему преобразования чисел. И хотя здесь трудно придумать что-то новое, эта тема заслуживает того, чтобы ей было уделено место в книге, посвященной вопросам прикладного программирования па ассемблере. В данной главе сделана попытка систематизированно рассмотреть различные существующие подходы к решению проблемы ввода-вывода числовой информации и ее преобразованию во внутреннее представление в компьютере.<br>
  Начнем с того, что вспомним урок 2 «Архитектура персонального компьютера» учебника, где приведена классификация типов данных, допустимых микропроцессором Pentium III. Для нашего изложения важно то, что они делятся на две большие группы — данные целочисленного и вещественного типов. Причем целочисленные данные можно разделить на две подгруппы: двоичные и двоично-десятичные (BCD-числа). Исходя из этого постараемся сформулировать направления преобразований числовой и символьной информации, востребованные на практике.<br>
  При обмене с консолью:</p>
      <ul>
        <li> десятичные целые числа в символьном виде &lt;-» внутреннее двоичное представление;</li>
        <li> шестнадцатеричные целые числа в символьном виде &lt;-» внутреннее двоичное представление;</li>
        <li> двоичные целые числа в символьном виде &lt;-&gt; внутреннее двоичное представление; </li>
        <li> десятичная дробь в символьном виде &lt;-&gt; внутреннее представление в виде<br>
    вещественного числа;</li>
        <li> дробное шестнадцатеричное число в символьном виде «-> внутреннее представление в виде вещественного числа; </li>
        <li> дробное двоичное число в символьном виде &lt;-&gt; внутреннее представление в<br>
    виде вещественного числа.<br>
    Взаимное преобразование между внутренними представлениями: </li>
        <li> двоичное число &lt;-» двоично-десятичное число; </li>
        <li> двоично-десятичное число &lt;-» вещественное число; </li>
        <li> двоичное целое число &lt;-&gt; вещественное число.</li>
      </ul>
    <p> Рассмотрим основные способы выполнения некоторых из этих видов преобразований. В своих рассуждениях будем предполагать, что числа положительные. Если вы внимательно изучили материал уроков 6 и 8 учебника, а также главы 1 этой книги, посвященной программированию арифметических операций над двоичными и двоично-десятичными числами, то вы легко сможете дополнить приведенные ниже программы возможностью учета знака при выполнении соответствующих преобразований.</p>      
    <p class="title_2"><a name="1"></a>Ввод чисел с консоли</p>    
    <p> В этом разделе разберем способы преобразования десятичных целых и вещественных чисел, вводимых с консоли в символьном виде, в соответствующее им внутреннее двоичное представление. Начнем с преобразования целых десятичных чисел. Заметим, что этот вид преобразования является наиболее востребованным на практике. Далее будет обсуждена проблема преобразования вещественных чисел.<br>
  Выбор способа преобразования десятичных целых чисел из символьного во внутреннее двоичное представление и обратно определяется диапазоном возможных исходных значений. Разберем два способа.</p>
    <p class="title_3"> <a name="2"></a>Ввод целых десятичных чисел из диапазона 0..99</p>
    <p> Для значений из диапазона 0..99 взаимное преобразование между символьной десятичной и двоичной формами может производиться командами умножения и деления двоично-десятичных (BCD-чисел) — ММ и AAD.</p>
    <p><br>
        <span class="listing">:prg06_01.asm - программа ввода с консоли двоичного числа из диапазона 0..99<br>
  :в десятичном символьном представлении<br>
  ;Вход: число в десятичной системе счисления, вводимое в символьном виде с клавиатуры.<br>
  ;Выход: двоичное число в регистре А1.<br>
  buf_Oahstruc<br>
  len_bufdb 3 :длина buf_0ah<br>
  len_in db 0 действительная длина введенного слова (без учета Odh)<br>
  bufjn db 3 dup (20h) :буфер для ввода (с учетом Odh)<br>
  ends<br>
  .data<br>
  bufbuf_0ah&lt;&gt;<br>
  adr bufdd buf<br>
  .code<br>
  ;.........<br>
  ;вводим 2 символа с клавиатуры, контроль на допустимые значения не делаем<br>
  Ids dx.adr__buf<br>
  nrav ah.Oah<br>
  int 21h<br>
  xor ax.ax<br>
  cmp buf .lenjn.2 ;сколько чисел введено реально?<br>
  jneml<br>
  mov ah.buf.buf_in ml: mov al,buf.buf_in+l<br>
  andax.0f0fh преобразование в неупакованное десятичное представление<br>
  aad :в al двоичный эквивалент исходного двузначного десятичного значения</span><br>
  <br>
  fbld string_pack :помещаем в стек сопроцессора 'fistp string_bin ;и извлекаем эквивалентное двоичное представление в поле string_bin '¦.........<br>
  Приведенная программа преобразует любое значение из диапазона 0..1018-!. Интересно отметить количественное значение максимальной двоичной величины, соответствующее верхней границе диапазона, — это +0de0b6b3a763ffffl6. Запомните его, оно пригодится нам при рассмотрении обратного преобразования Для вывода на консоль — из двоичного в десятичное представление. Извлечь значение нужной разрядности можно, если ввести директивой label соответствующие идентификаторы в исходный текст программы (что и сделано в нашем сегменте кода):</p>
    <p class="title_3">        <a name="3"></a>Ввод целых десятичных чисел из диапазона 0..4 294 967 295</p>
    <p>        Если исходное значение выходит за диапазон 0..99, то здесь следует иметь в виду возможность возникновения ситуации, при которой значение вводимого десятичного числа превышает диапазон, допустимый форматами типов целочисленных данных, поддерживаемых, в частности, арифметическими командами микропроцессора. Для Pentium III это 8, 16 и 32 бита. Допустимые диапазоны значений для этих форматов (числа без знака):</p>    <ul>
      <li> для операнда размером 8 бит — 0..255;</li>
      <li> для операнда размером 16 бит — 0..65 535;</li>
      <li> для операнда размером 32 бита — 0..4 294 967 295.</li>
    </ul>
    <p> Как видите, максимальное число не такое уж и большое. Поэтому мы столько внимания уделили работе с числами большой размерности в главе 1, посвященной программированию арифметических операций. В ней данные большой размерности просто описывались в сегменте данных без какого-либо намека на возможность их ввода с консоли или отображения на ней. В этом разделе мы постараемся ликвидировать этот недостаток, что несомненно поднимет привлекательность для читателя того и другого материала. Но вначале мы рассмотрим способы преобразования значений, которые укладываются в указанные выше диапазоны. Для этого можно предложить два способа преобразования в символьном представлении десятичных чисел, вводимых с консоли: с использованием деся-<br>
  точного полинома и с использованием возможностей сопроцессора по обработке<br>
  данных.<br>
  В основе способа с использованием десятичного полинома лежит возможность представления десятичного числа суммой произведений на степени числа 10 составляющих его десятичных цифр, которые соответствуют позициям этих цифр в исходном числе:</p>
    <p> А10 = an.,x10nl + an.2x10&quot;-2 + ... + а,х10 + а0х10°.</p>
    <p> Вычисление данного полинома лучше производить по схеме Горнера:</p>
    <p> А10 - (...(0+an.,)x10+an.2)x10+ ... + а,)х10+а0.</p>
    <p> Например, число 3405 по этим формулам может быть представлено так:</p>
    <p> 3405=Зх103+4х102+Ох101+5х100=(((0+3)х10+4)х10+0)х10+5.</p>
    <p> Ниже приведена программа преобразования целого десятичного числа в символьном виде из диапазона 0..4 294 967 295 в эквивалентное двоичное представление. Для ввода числа с клавиатуры используем функцию 3fh MS D0S. Она удобна тем, что возвращает количество действительно введенных символов в регистре AL.</p>
    <p class="listing"> :prg06_02.asm - программа преобразования целого десятичного числа в символьном виде :из диапазона 0..4294967295 в эквивалентное двоичное представление. <br>
  :Вход: ввод с клавиатуры числа в десятичной системе счисления (не более 10 цифр). <br>
  :Выход: двоичное число-результат преобразования в регистре ЕАХ.<br>
  add eax.edx<br>
  mul ten<br>
  jc exit_e<br>
  inc si<br>
  loop ml m2: mov dl .[si]<br>
  anddl.Ofh преобразуем ASCI I-&gt;BCD<br>
  add еах^х;результат преобразования в регистре ЕАХ<br>
  jncexit результат вышел за границы операнда exit_e: .выводим строку string_e на экран</p>
    <p> При необходимости вы можете изменить программу, так чтобы в ней использовались регистры меньшей разрядности.</p>
    <p> <a name="4" id="4"></a>Ввод целых десятичных чисел из диапазона 0..999 999 999 999 999 999</p>
    <p> Второй способ преобразования десятичных чисел хотя и выглядит несколько экзотически, вполне работоспособен. Данный способ предполагает использование особенностей некоторых команд сопроцессора. В материале урока 19 «Архитектура и программирование сопроцессора» учебника мы перечисляли форматы данных, которые поддерживает сопроцессор. Перечислим их еще раз:</p>
    <ul>
      <li> двоичные целые числа в трех форматах — 16, 32 и 64 бита;</li>
      <li> упакованные целые десятичные (BCD) числа — максимальная длина -18 упакованных десятичных цифр (9 байт);</li>
      <li> вещественные числа в трех форматах — коротком (32 бита), длинном (64 бита), расширенном (80 бит).</li>
    </ul>
    <p> Для нас интерес представляют форматы целых двоичных и упакованных десятичных (BCD) чисел, а также команды обмена этими значениями с вершиной сопроцессора. Процесс преобразования десятичного целого числа, вводимого с клавиатуры, показан в программе ниже. Необходимо отметить, что этот способ преобразования позволяет расширить диапазон значений 0..999 999 999 999 999 999.</p>
    <p> <span class="listing">:prg06_03.asm - программа ввода целых десятичных чисел из диапазона<br>
  :0..999 999 999 999 999 999 и преобразования их в эквивалентное двоичное представление.<br>
  ;Вход: ввод с клавиатуры числа в десятичной системе счисления<br>
  :в диапазоне значений 0..999 999 999 999 999 999.<br>
  :Выход: двоичное число-результат преобразования в области памяти stnng_bin.<br>
  .data<br>
  db 0 :барьер. если введенное количество цифр нечетно string db 20 dup (0) максимальное исходное число состоит из 18 цифр (20 - с учетом<br>
  Od0ah)<br>
  len_string=$-string adr_string dd string<br>
  string_pack dt 0 :сюда упаковывается исходное значение<br>
  len_string_pack=$-string_pack adr_string_pack dd string_pack результат - двоичное значение различной разрядности: </span></p>
    <p class="listing">string_bin_byte label byte<br>
  string_bin_word label word<br>
  string_bin_word label word<br>
  string_bin_dword label dword</p>
    <p class="listing"> string_bindq 0 ;поле для результата - эквивалентного двоичного представления<br>
        <br>
  --------вводим с экрана----------------............-----<br>
  movbx.O стандартный дескриптор - клавиатура<br>
  movcx. len_str&quot;ing<br>
  lea dx.string :формируем указатель на строку string<br>
  movah.3fh :номер функции DOS<br>
  int 21h<br>
  jc exit ;переход в случае ошибки<br>
  ;в регистре AL - количество действительно введенных десятичных цифр :преобразуем строку с десятичными числами в ее двоичный эквивалент<br>
  mov ex.ax<br>
  subcx,2 корректируем счетчик цикла (чтобы не учитывать OdOah, вводимые 3fh)<br>
  jeexz exit :число не было введено<br>
  Ids si ,adr_string<br>
  add si,cx<br>
  dec si указатель на последнюю введенную десятичную цифру<br>
  les di.adr_string_pack ml: std :флаг df=l - работаем со строкой string, начиная с ее конца<br>
  хог ах.ах<br>
  lodsb<br>
  and al. Of h<br>
  shl ax.8<br>
  lodsb<br>
  shl al .4<br>
  add al.ah :в AL две очередные упакованные цифры<br>
  eld :флаг df-1 - работаем со строкой string_pack. начиная с ее начала<br>
  stosb<br>
  sub ex.2<br>
  emp ex. 0<br>
  J9 ml ;конец преобразования в упакованное представление<br>
  fI nit инициализируем сопроцессор ;теперь преобразуем в эквивалентное двоичное представление:<br>
  fbld string_pack :помещаем в стек сопроцессора 'fistp string_bin ;и извлекаем эквивалентное двоичное представление в поле string_bin </p>
    <p> Приведенная программа преобразует любое значение из диапазона 0..1018-!. Интересно отметить количественное значение максимальной двоичной величины, соответствующее верхней границе диапазона, — это +0de0b6b3a763ffffl6. Запомните его, оно пригодится нам при рассмотрении обратного преобразования Для вывода на консоль — из двоичного в десятичное представление. Извлечь значение нужной разрядности можно, если ввести директивой label соответствующие идентификаторы в исходный текст программы (что и сделано в нашем сегменте кода): </p>
    <p class="listing">string_bin_byte label byte<br>
  string_bin_word label word<br>
  string_bin_word label word<br>
  string_bin_dword label dword </p>
    <p class="title_3"> <a name="5"></a>Ввод целых десятичных чисел из диапазона 0..до оо </p>
    <p> Для преобразования десятичного числа произвольной разрядности из символьного представления в двоичное потрудиться придется несколько больше. Основа для этой работы была создана в материале, посвященном арифметическим операциям для чисел произвольной разрядности. Поэтому наши действия при разработке программы преобразования напомнит игру с конструктором, когда из готовых компонент будет создаваться новый продукт.<br>
  Исходными компонентами программы преобразования десятичного числа произвольной разрядности из символьного представления в двоичное будут являться макрокоманда умножения N-байтного числа на число размером М байт и программа сложения чисел размером N байт без учета знака. Алгоритм вычисления двоичного эквивалента будет таким же, как рассмотренный выше, — вычисление полинома по схеме Горнера. Ниже приведен вариант реализующей его программы. Расположение байтов результата — по схеме, естественной для микропроцессоров Intel, то есть младший байт располагается по младшему адресу.</p>
    <p class="listing"> :prg06_04.asm - программа ввода целых десятичных чисел из диапазона 0..». ;Вход: ввод с клавиатуры числа в десятичной системе счисления длиной до 20 цифр. ;Выход: двоичное число - результат преобразования в области памяти string_bin.<br>
  :см. описание макрокоманд add_unsign_N_l и mul_unsign_NM в главе 1 add_unsIgn_N_lmacro summand_l, summand_2, N<br>
  endm mul_unsign_NM macro u.i.v.j.w<br>
  endm .data<br>
  string db 22 dup (0) максимальное число состоит из 20 цифр (22 - с учетом OdOah) len_string-$-string tendd 10<br>
  string_bindb 10 dup (0) максимальная длина двоичного числа - 10 байт 1en_stri ng_bi n-$-stri ng_bi n<br>
  carry db 0 :перенос сложения последних байтов<br>
  adr_string_bindd string_bin string_bin_w db len_string_bin+l dup (0) результат умножения для макроса<br>
  ;mul_unsign_NM = len_string_bin+l байт len_string_bin_w =$-string_bin_w adr_string_bin_w dd string_bin_w k db 0 :перенос 0 &lt; k &lt; 255<br>
  b dw lOOh ;размер машинного слова<br>
  .code<br>
  movbx.O стандартный дескриптор - клавиатура<br>
  mov cx.len_string<br>
  lea dx.string ;формируем указатель на строку string<br>
  movah,3fh :номер функции DOS<br>
  int 21h<br>
  jc exit :переход в случае ошибки :в регистре AL - количество действительно введенных десятичных цифр<br>
  mov ecx.eax<br>
  sub есх.2 корректируем счетчик цикла (чтобы не учитывать OdOah. вводимые 3fh)<br>
  jcxz $+4 :число не было введено<br>
  jmp $+5<br>
  jmp exit cont_l:dec ecx ;не умножать на 10 последнюю цифру числа<br>
  jcxz $+4 юднозначное число<br>
  tjmp S+5 jmp m2 lea si.string ;формируем указатель на строку string хог еах.еах :еах:=0 ml: хог edx.edx<br>
  mov dl.[si]<br>
  and dl.Ofh преобразуем ASCI I-&gt;BCD add_unsign_N_lstring_bin.dl. len_string_bin ¦.умножаем на 10<br>
  mul_unsign_NM string_bin. len_string_bin.ten,l. string_bin_w :копируем string bin_w в string_bin<br>
  eld<br>
  push si push ex<br>
  Ids si .adr_sthng_bin_w<br>
  lesdi.adr_string_bin<br>
  mov cx.len_string_bin_w repmovsb pop ex pop si<br>
  inc si dec ex jcxm2 ' jmp ml m2: mov dl .[si] and dl.Ofh<br>
  ¦ add_unsign_N_lstring_bin.dl, len_string_bin<br>
  ¦ результат преобразования - в строке string_bin</p>
    <p> Одно из направлений совершенствования этой программы — динамическое \ выделение памяти для всех чисел с неизвестной длиной. Необходимо заметить, i что способ преобразования длинных чисел универсален — его можно использовать и для преобразования значений, которые укладываются в представимые в микропроцессоре диапазоны типов данных.</p>
    <p class="title_3"> <a name="6"></a>Ввод вещественных чисел</p>
    <p> Теперь у нас все готово для того, чтобы выполнить ввод с клавиатуры символьного представления вещественного числа и преобразование его в соответствующий двоичный эквивалент. В уроке 19 «Архитектура и программирование сопроцессора» учебника мы обсуждали понятие вещественного числа. Отмечалось, что вещественное число имеет две формы записи — с плавающей точкой (34.89) и научную (3.45е-3=3.45х103). Для преобразования вещественного числа из символьного представления в эквивалентное двоичное можно предложить несколько способов. Самый простой — использовать возможность загрузки в сопроцессор упакованного BCD-числа. В этом случае алгоритм преобразования состоит в следующем. Символьная строка с вещественным числом вводится в память, где она преобразуется в упакованное BCD-число. При вводе указанной символьной строки запоминается положение плавающей точки. Полученное упакованное BCD-число загружается в сопроцессор, после чего оно делится на 10 в степени, соответствующей положению плавающей точки в исходном числе. Для малых чисел (в диапазоне до |1018-1|) этот способ вполне хорош. Его можно расширить, если вводить число в научном формате, при этом процесс перевода мантиссы аналогичен рассмотренному выше, но при подготовке к делению на степень 10 необходимо учесть значение степени, указанное после символа «е». Но все равно, несмотря на расширения диапазона, разряднорть мантиссы ограничена 18 цифрами. Устранить этот недостаток можно, используя операции с числами произвольной разрядности. Этот способ интересен своей универсальностью, поэтому уделим ему основное внимание.<br>
  Итак, разработаем программу ввода вещественного числа с клавиатуры в одном из двух возможных форматов — простом формате с плавающей точкой. Доработать программу для использования научного формата для вас не составит труда.<br>
  В качестве знаков, разделяющих мантиссу на целую и дробную части, можно использовать как запятую, так и точку. Суть алгоритма преобразования состоит в следующем. Производится ввод с клавиатуры символов вещественного числа. После ввода анализируются символы буфера, куда было помещены символы введенного числа, на предмет выяснения положения плавающей точки. Обнаруженная позиция запоминается. Относительно нее введенные символы делятся на символы цифр целой и дробной частей. Используя алгоритм преобразования символьного представления десятичного числа в двоичный эквивалент, преобразуется целая часть вещественного числа. Дробная часть вещественного числа также преобразуется в двоичный эквивалент. Это преобразование производится с использованием сопроцессора по формуле: ((...(u_m/b+u1_m)/b+...+u_2)/b+u.,)/b, где un — символы десятичных цифр дробной части вещественного числа u_mu1_n,..-u.2u_,, b=10. После того как данное выражение вычислено (его результат находится в вершине стека сопроцессора), производится сложение его результата с преобразованной целой частью вещественного числа. Все, теперь в вершине стека сопроцессора находится вещественное число — эквивалент своего исходного символьного представления. Текст программы преобразования вещественного числа из символьного представления достаточно велик и по этой причине приведен на дискете (prg06_05.asm). Заметьте, что с целью экономии места никаких проверок<br>
  на правильность формата вводимого вещественного числа в программе не делается.<br>
  Последнее замечание — об ограничениях на размерность исходного числа. Здесь следует различать размерности целой и дробной частей. Что касается дробной части, то здесь вообще ограничений нет, за исключением тех, которые накладывает сам сопроцессор на вводимые в его регистры значения. Для целой части узкое место — максимальная размерность операнда в команде целочисленного сложения FIADD, которая составляет 32 бита.<br>
  Ввод шестнадцатеричных и двоичных чисел мы рассматривать не будем, так как общие принципы их ввода аналогичны рассмотренным выше для десятичных чисел. Потребность в вводе с клавиатуры шестнадцатеричных и двоичных чисел возникает значительно реже, чем десятичных.</p>
    <p class="title_2">        <a name="7"></a>Вывод чисел на консоль</p>    <p> В этом разделе мы рассмотрим алгоритмы обратного преобразования чисел — из внутреннего двоичного представления в число в символьном виде, формат записи которого соответствует правилам требуемой системы счисления. Необходимо предупредить читателя, что рассмотрение обратного преобразования не будет симметричным рассмотренному выше прямому преобразованию. И в подтверждение этому начнем обсуждение проблемы вывода чисел на консоль с алгоритма преобразования шестнадцатеричных чисел в символьное представление.</p>
    <p class="title_3">        <a name="8"></a>Вывод шестнадцатеричных чисел</p>
    <p>        Умение работать с шестнадцатеричными числами — необходимое условие успешного программирования на низком уровне. Шестнадцатеричные числа по сравнению с двоичными являются более естественными для анализа внутреннего представления информации в компьютере. Вспомним, что каждый байт — это совокупность двух тетрад, а диапазон значений, представимых одной тетрадой, как раз совпадает с диапазоном значений, которые может принимать однозначное шестнадцатеричное число. Поэтому сам процесс преобразование шестнадцатеричных чисел в символьное представление особого труда не представляет. Например, алгоритм вывода на консоль содержимого одного байта состоит в выделении некоторым способом значений его младшей и старшей тетрад и дальнейшее их преобразование в символьное представление. Если нужно вывести на консоль символьное представление более чем одного байта, то процесс выделения тетрад и их преобразования выполняется последовательно необходимое количество раз.<br>
        В качестве полезной иллюстрации алгоритма преобразования шестнадцате-ричной информации в символьное представление рассмотрим макрокоманду SHOW, которая преобразует содержимое одного из четырех регистров — AL, АН, АХ, ЕАХ в символьное шестнадцатеричное представление. Этот макрос является универсальном средством, которое позволяет осуществить «подглядывание» за содержимым регистра или области памяти динамически, во время выполнения программы. С помощью этого макроса можно визуализировать содержимое любого<br>
        из доступных регистров или области памяти длиной до 32 бит. Для этого доста точно лишь переслать содержимое нужного объекта (регистра или ячейки памяти} с учетом его размера в один из регистров AL, АН, АХ, ЕАХ. Имя одного из этих регистров указывается затем в качестве фактического аргумента макрокоманды SHOW Второй аргумент этого макроса — позиция на экране. Задавая определенные значения, мы можем судить о том, какая именно макрокоманда SHOW сработала. Еще одна немаловажная особенность данного макроса состоит в его возможности работать как в реальном, так и защищенном режимах. Распознавание текущего режима работы микропроцессора выполняется автоматически. Проверить работу данного макроопределения вы можете с помощью следующей программы.<br>
        Ниже приведены фрагменты текста макрокоманды SHOW. Полный текст этой макрокоманды имеется в <a href="../PRIMER.exe">ПРИМЕР</a>е.</p>    <p class="listing"> :show.inс<br>
  макроопределение для визуализации регистров AL. АН. АХ. ЕАХ<br>
  ;:на входе:<br>
  :;агд_п - имя одного из регистров AL. АН, АХ. ЕАХ<br>
  ;;п_ро2 - номер позиции на экране, по умолчанию - 1000<br>
  Show MACRO a rg_n.n_poz:=&lt;1000&gt;<br>
  LOCAL mai n_part.di sp.pause.tempi ate,VideoBuffer.pjnode.ml.m2<br>
  :;переход на начало блока команд, чтобы избежать выполнения данных<br>
  jmpmain_part ;:некоторые константы и переменные<br>
  main_part: :начало блока команд<br>
  сохранение в стеке используемых регистров: ЕАХ. ЕВХ. ЕСХ. EDX. EDI. DS. ES<br>
  push cs<br>
  pop ds :в bx - адрес таблицы-шаблона (для xlat)<br>
  lea bx.cs:tempi ate<br>
  xor ex.ex :очистка сх<br>
  :начало блока определения того, какой регистр был передан макросу IFIDNI &lt;al&gt;.&lt;&amp;arg_n&gt; :если аргумент=а1 или AL. ?reg8bit=TRUE установка флага 8-битового регистра<br>
  mov ah.al ENDIF<br>
  ;передан не al или AL<br>
  IFIDNI &lt;ah&gt;.&lt;&amp;arg_n&gt; :если аргумент-ah или АН.<br>
  ?reg8bit=TRUE -.установка флага 8-битового регистра<br>
  ENDIF<br>
  ;передан не АН или ah<br>
  IFIDNI &lt;ax&gt;.&lt;&amp;arg_n&gt; ;если аргумент равен ах или АХ,<br>
  ?regl6bit=TRUE -.установка флага 16-битового регистра<br>
  ENDIF<br>
  ;передан не ah. АН ,ах или АХ .¦ _ ,;.<br>
  обработка содержимого регистров AL. АН, АХ. ЕАХ IF (?reg8bit) -.если передан а! или ah -:&quot;'&quot;&quot; &quot;' push eax -.-'- ¦<br>
  and ah. Of Oh; обращение к старшей четверке битоВ'.-ah' shr ax. 12 -.сдвиг битов в начало (16-4=12) xlat трансляция таблицы-шаблона помещение символа из al в edi ¦¦j:\--.i ¦.;¦,.&gt; -«-.iY ¦ ';¦' mov di.ax ¦ ¦ ,k ,-,,<br>
  shl di .8 inc ex pop eax and ax.OfOOh shr ax.8 xlat<br>
  or di.ax<br>
  shl edi. 16 . , ...<br>
  inc ex ENDIF ¦ IF (?regl6bit) ;если передан ах или ах<br>
  -.начало обработки значения регистра АХ push eax<br>
  -.обращение к старшей четверке битов ах .<br>
  and ax.OfOOOh .',.<br>
  shr ax.12 ;сдвиг битов в начало (16-4=12) xlat трансляция таблицы-шаблона ......<br>
  помещение символа из а! в старшую тетраду старшей половины ЕЩ . &quot;,, mov di ,ax *i<br>
  shl edi.8 <br>
  inc ex <br>
  pop eax push eax обращение ко второй четверке битов ах<br>
  and ax.OfOOh<br>
  ' shr ax,8 ;сдвиг битов в начало (16-(4+4)=8)<br>
  xlat -.трансляция таблицы-шаблона<br>
  .помещение очередного символа в младшую тетраду старшей половины EDI<br>
  or di.ax<br>
  shl edi.8<br>
  inc ex ' ' . '' '&quot;.¦;;1<br>
  pop eax .<br>
  push eax<br>
  and ax.OfOh;обращение к третьей четверке битов в АХ -. v.'v<br>
  shr ax.4 ;сдвиг битов в начало (16-(4+4+4)=4) ¦xlat трансляция таблицы-шаблона<br>
  or di.ax -.помещение очередного символа в EDI<br>
  ! shl edi.8<br>
  i nc ex<br>
  pop eax<br>
  and ax.Ofh обращение к младшей четверке битов АХ<br>
  xlat трансляция таблицы-шаблона<br>
  or di.ax помещение очередного символа в EDI<br>
  inc ex ENDIF<br>
  IF (?reg32bit) ;если передан ЕАХ или ЕАХ ;начало обработки значения регистра ЕАХ аналогично АХ<br>
  ENDIF<br>
  ;вывод на экран результата с учетом режима работы микропроцессора результат - в паре EDX:ЕВХ. количество цифр - в СХ<br>
  :.........<br>
  ENDM</p>
    <p> <a name="9"></a><span class="title_3">Вывод целых десятичных чисел из диапазона 0..99</span></p>
    <p> Выше упоминалось, что для значений из диапазона 0..99 взаимное преобразование между символьной десятичной и двоичной формами может производиться командами умножения и деления двоично-десятичных (BCD-чисел) — ААМ и AAD.</p>
    <p class="listing"> ;prg06_07.asm - ввод с консоли десятичного числа из диапазона 0..99<br>
  :и обратный его вывод на консоль.<br>
  buf_Oahstruc<br>
  len_bufdb 3 ;длина buf_0ah<br>
  len_in db 0 .действительная длина введенного слова (без учета Odh)<br>
  bufjn db 3 dup (20h) :буфер для ввода (с учетом Odh) ends .data<br>
  bufbuf_0ah&lt;&gt; adr_bufdd buf ' .code<br>
  :вводим 2 символа с клавиатуры, контроль на допустимые значения не делаем<br>
  ldsdx.adr_buf<br>
  mov ah.Oah<br>
  int 21h<br>
  хог ах.ах<br>
  emp buf .len_in,2 .-сколько чисел введено реально?<br>
  jne ml<br>
  mov ah.buf .bufjn ml: mov al.buf,buf_in+l<br>
  andax.OfOfh преобразование в неупакованное десятичное представление<br>
  add :в AL двоичный эквивалент исходного двузначного десятичного значения ;вывод на консоль содержимого AL<br>
  аат<br>
  mov dx.ax<br>
  or dx.03030h<br>
  rol dx.8 :выводим старшую цифру<br>
  mov ah,2<br>
  int 21h<br>
  rol dx.8 :выводим младшую цифру<br>
  int 21h</p>
    <p> Для преобразования с целью последующего вывода на консоль больших двоичных значений можно использовать два способа: путем деления по модулю 10 (диапазон значений не ограничен) и с помощью сопроцессора (0..1018-1).</p>
    <p class="title_3"> <a name="10"></a>Вывод целых десятичных чисел из диапазона от 0 до оо </p>
    <p> Для вывода двоичных значений из диапазона от 0 до бесконечности используется способ, в основе которого лежит получение остатков при последовательном делении исходного значения на 10.<br>
  В основе алгоритма лежит положение о том, что цифры (...U2U,U0) десятичного представления начиная с младшей получаются последовательным делением исходного двоичного значения и на 10:<br>
  U0=u mod 10; U1Lu/10j mod 10; U2 41u/10j /10J mod 10 и т. д., до тех пор пока после очередного деления делимое не окажется равным нулю: L.-iLu/10j/10j..J=0 Здесь символы L и J обозначают целую часть частного, округленного в меньшую<br>
  сторону.<br>
  Почему в отличие от алгоритмов ввода с консоли для обратного преобразова ния нет такого разнообразия способов? Это объясняется особенностью командь деления DIV микропроцессора, которая используется в описанном выше алгорит ме для получения частного и остатка. Ее требование к соотношению значенш делимого и делителя — размер частного должен быть в два раза меньше делимо го. В противном случае возникает исключение #0Е (ошибка деления) и програм ма аварийно завершается.<br>
  Исходя из этих условий нам ничего не остается, кроме как воспользоватьс программой беззнакового деления значения размером N байт на значение разме ром 1 байт. Она была рассмотрена в главе 1, посвященной целочисленным ариф метическим операциям. Для удобства использования эту программу мы офор мим в виде макрокоманды.</p>
    <p class="listing"> :prg06_08.asm - программа вывода целых десятичных чисел из диапазона О..оо.<br>
  ;Вход: многобайтное двоичное число для преобразование в области памяти bin_dd.<br>
  :Выход: вывод десятичного числа из диапазона 0..&lt;ю на экран.<br>
  :<br>
  div_unsign_N_l_I macro u.N.v.w.r<br>
  :div_unsign_N_l_I - макрокоманда деления N-разрядного беззнакового целого<br>
  :на одноразрядное число размером 1 байт (порядок следования байтов - младший байт<br>
  :по младшему адресу (Intel)). См. главу 1 и дискету<br>
  endm .data string db 10 dup (0) ;пусть максимальное десятичное число состоит из 10 цифр<br>
  len_string-$-string adr string dd string b1n~dd label BYTE &quot;dd Offffffffh 1 еп_Ы n_dd-$ - bi n_dd ten*db To remainder dw 0 .code<br>
  значение для преобразования должно быть в памяти<br>
  les di,adr_string строка с десятичными символами<br>
  eld обработка в прямом направлении<br>
  continue:<br>
  di v_unsign_N_l_I bin_dd.1en_bin_dd.ten.Ыn_dd.remainder<br>
  mov ax.remainder<br>
  or al.30h :преобразуем в символьное представление<br>
  stosb сохраняем в string очередную десятичную цифру<br>
  inccx {подсчитываем количество цифр<br>
  cmpbinjjd.0<br>
  jne continue :вывод на консоль с конца строки<br>
  mov ah,2<br>
  std<br>
  mov si .di<br>
  dec si ml: &quot;lodsb<br>
  mov dl ,al<br>
  Int 21h<br>
  loop ml</p>
    <p> В данной программе преобразованию подвергается значение в памяти. Причем мы в качестве исходного двоичного значения задали максимально возможное беззнаковое число размером в двойное слово. Результат преобразования — 4 294 967 295, что полностью сходится с ожидаемым десятичным значением. Но задавать исходные значения в памяти не всегда удобно, хотелось бы, чтобы можно было подвергать преобразованию значения прямо из регистров процессора. Для такого типа преобразований (значений в регистрах процессора) лучше подойдет способ с использованием сопроцессора. Рассмотрим его.</p>
    <p> <a name="11"></a><span class="title_3">Вывод целых десятичных чисел из диапазона 0..999 999 999 999 999 999</span></p>
    <p> Этот способ вывода основан на возможности сопроцессора работать с упакованными десятичными числами. Выше мы уже рассматривали преобразование десятичных чисел в двоичное представление с использованием этой возможности. Система команд сопроцессора содержит команду FBSTP, которая сохраняет десятичное число из вершины стека сопроцессора в области памяти с одновременным преобразованием этого числа в формат десятичного числа. Область памяти, в которую происходит сохранение, должна быть описана директивой DT. Важно отметить, что команда FILD, с помощью которой вы будете помещать целое число в сопроцессор для дальнейшего преобразования, трактует целые числа как числа со знаком. Поэтому попытка задать целое число в виде Offffh (с единичным старшим разрядом операнда) приведет к тому что в стек сопроцессора будет помешено значение со всеми вытекающими отсюда последствиями для результата преобразования.</p>
    <p class="listing"> ;prg06_09.asm - программа вывода целого десятичного числа<br>
  :из диапазона 0..999 999 999 999 999 999 на экран.<br>
  ¦.Вход: выводимое значение - в поле string_bin_dword.<br>
  ¦.Выход: вывод десятичного числа из диапазона 0. .999 999 999 999 999 999 на экран.<br>
  .data<br>
  :поле string_bin_dword содержит выводимое значение - с помощью идентификаторов.<br>
  :вводимых директивой label, это значение может трактоваться как значение<br>
  различной разрядности:<br>
  string_bin_byte label byte<br>
  string_bin_word label word<br>
  string_bin_dword label dword<br>
  string_bin_qword dq 0de0b6b3a763ffffh :зададим максимально возможное<br>
  ¦.для сопроцессора двоичное целое со знаком<br>
  ;в string_pack исходное значение из string bin_dword в упакованном десятичном формате string_pack dt О len_string_pack=$-string_pack adr_string_pack dd string_pack string db 20 dup (0) максимальный результат состоит из 18 десятичных цифр<br>
  len_string-$-string adr_stringdd string<br>
  .code<br>
  :.........преобразуем bin-&gt;dec <br>
  finit<br>
  fild string_bin_qword ;заносим в сопроцессор двоичное целое число fbstp string_pack извлекаем упакованное десятичное :.........распакуем........................................<br>
  Ids si.adr_string_pack<br>
  add si.len_string_pack-2 ;на конец string_pack (18 упак. дес. цифр)<br>
  les di.adr_string<br>
  mov ex.9 :9 пар упакованных десятичных цифр<br>
  cycl: xorax.ax<br>
  std :string_pack обрабатываем с конца<br>
  lodsb :в al очередные 2 упакованные десятичные цифры<br>
  ¦»;распаковываем - ah-младшая. al-старшая<br>
  shi ax.4<br>
  rol al.4<br>
  ог ах.З0З0п треобразуем в символьное представление<br>
  xchg ah.al iah-младшая, al-старшая<br>
  eld ;в string записываем с начала<br>
  stosw<br>
  loop cycl :.........выводим на консоль...............................<br>
  mov bx.l -.стандартный дескриптор - экран<br>
  mov cx.len_string<br>
  Ids dx.adr_string {формируем указатель на строку string<br>
  mov ah.40h ;номер функции DOS<br>
  int 21h :выводим<br>
  jc exit :переход в случае ошибки</p>
    <p class="title_3"> <a name="12"></a>Вывод вещественных чисел</p>
    <p> Последнее преобразование, которое мы рассмотрим в этом разделе, — преобразование вещественного значения в вид, пригодный для его визуализации на экране консоли. Ниже приведены только те фрагменты программы, которые относятся непосредственно к преобразованию. Полный текст программы находится в <a href="../PRIMER.exe">ПРИМЕР</a>е.</p>
    <p class="listing"> ;prg06_10.asm - программа вывода вещественного числа короткого формата (32 бита).<br>
  ;Вход: выводимое значение - в поле float32.<br>
  :Выход: вывод вещественного числа короткого формата на экран<br>
  .data<br>
  dec_bin_mant32dt 0 ;мантисса в двоично-десятичном представлении<br>
  dec_bin_har32 dt 0 характеристика в двоично-десятичном представлении<br>
  cwr dw 0 переменная для сохранения состояния per. cwr<br>
  ten dw 10 ;константа, равная 10<br>
  float32dd 1.2345678el2 значение вещ. числа размером в 32 бита для вывода<br>
  mant32 dd 0 :мантисса в двоичном представлении .<br>
  har32 dd 0 характеристика - вещ. формат в двоичном представлении<br>
  int_har32 dd 0 характеристика - целое в двоичном представлении<br>
  number db 0<br>
  char db 0<br>
  cursor_column db 0<br>
  cursorjine db 0<br>
  number_of_digits db 9<br>
  flag db 0<br>
  .code<br>
  next_cursor_column ргос .-процедура сдвига курсора на одну позицию вправо<br>
  обязательно наличие в программе процедур::read_cursor_position, set_cursor_position<br>
  next_cursor_column endp<br>
  set_cursor_position ргос .'процедура позиционирования курсора<br>
  set_cursor_position endp<br>
  read_cursor_position ргос процедура определения текущей позиции курсора<br>
  read_cursor_position endp<br>
  print_charргос процедура вывода символа с учетом цвета<br>
  ;.........<br>
  printjrhar endp<br>
  positivejiar ргос<br>
  :выделение мантиссы из короткого формата (32бита) и ее преобразование<br>
  :в двоично-десятичный формат (для положительной характеристики<br>
  результат в st(0))<br>
  fimul ten<br>
  sub int_har32,6 lab_p_h: fidiv ten<br>
  cmp int_har32.0<br>
  dec int_har32 jg lab_p_h ret I positivejiar endp<br>
  negativejiar ргос<br>
  :выделение мантиссы из короткого формата (32 бита) и ее преобразование<br>
  ;в двоично-десятичный формат (для отрицательной характеристики результат в st(0))<br>
  fidiv ten<br>
  sub int_har32.7 lab_n_h: fimul ten<br>
  cmp int_har32.0<br>
  inc int_har32<br>
  jl lab_n_h<br>
  ret<br>
  negative_har endp fprint32 proc :вывод вещественного числа (32 бита) в десятичном виде<br>
  pusha<br>
  установка размера мантиссы в 24 бита fstcw cwr and cwr.1111000011111111b<br>
  or cwr.ldew cwr<br>
  fid float32:загрузка 32-битного числа в стек сопроцессора fxtract выделение мантиссьКБШ и характеристики^!) fstp mant32 запоминаем мантиссу fist har32 '.запоминаем характеристику щеревод двоичн. характеристики в дес. характеристику fldlg2 -.загрузка десят. лог. двух fimul har32 -.умножение двоичной хар-ки на 1од10(2) frndint -.округление fistp int_har32 сохранение десетяч. характеристики<br>
  fild int_har32<br>
  fbstp dec_bin_har32 сохранение двоично-десятичного значения характеристики<br>
  :выбор процедуры по выделению мантиссы fid float32 cmp har32.0 jge easel<br>
  call negativejiar :вызвать процедуру преобразования мантиссы, -.если хар-ка отрицательная<br>
  jmp end_case<br>
  I^casel: call positivejiar -.вызвать процедуру преобразования мантиссы, -.если хар-ка положительная end_case-. fbstp dec_bin_mant32 сохранение двоично-десятичного представления мантиссы ;вывод на экран вещественного числа lea si.dec_bin_mant32 add si.9 mov- a &quot;I. [si] : вывод знака числа cmp al .0 je zero mov char.&quot;-&quot; call print_char call next_cursor_column<br>
  :данный фрагмент пропускает байты с нулевым содержимым до первого байта ;со значащей цифрой zero: dec si<br>
  dec number_of_digits mov al.[si] cmp a 1.0<br>
  jne first_zero ;найден первый байт со значением, отличным от нуля jmp zero ;байт имеет нулевое значение - продолжаем поиск ; просмотр полубайтов первого найденного байта с ненулевым значением first_zero: and al ,11110000b cmp a 1,0 je second_digit :если старший полубайт байта равен нулю, начинаем вывод<br>
  :со второго байта jmp first_digit :если старший полубайт байта не равен нулю, начинаем вывод<br>
  :с первого байта :начало цикла вывода мантиссы print_digits: dec si<br>
  dec number_of_digits :индекс выводимого байта mov al.[si]<br>
  :вывод первого полубайта, содержащего цифру first_digit: andal ,11110000b shr al.4 add al.30h mov char.al<br>
  call print_char ,<br>
  call next_cursor_column<br>
  ;если выводимая цифра первая, то выводим после нее точку cmp flag.0 jne second_digit mov char.&quot;.&quot; call print_char ca11 next_cursor_column inc flag<br>
  :вывод второго полубайта, содержащего цифру second_digit: mov al. [si] and al,00001111b add a1,30h mov char.al call print_char call next_cursor_column<br>
  .-если выводимая цифра первая, то выводим после нее точку cmp flag,0 jne nonfirst_digit mov char,&quot;.&quot; call print_char call next_cursor_column inc flag<br>
  nonfi rst_digit: cmp number_of_d1g1ts.O jne print_digits mov flag,0<br>
  :вывод характеристики числа mov char,&quot;E&quot; call print_char call next_cursor_column lea si,dec_bin_har32<br>
  :вывод знака числа add si.9 mov al,[si] cmp al.O je printjiar mov char,&quot;-&quot; call print_char call next_cursor_column : значения характеристики print_har: sub si .9<br>
  mov al.[si] ;вывод первой цифры характеристики<br>
  and al.11110000b<br>
  shr al.4<br>
  add al.30h<br>
  mov char.al<br>
  call print_char<br>
  call next_cursor_col umn : вывод второй цифры характеристики<br>
  mov al.[s1]<br>
  and al.00001111b<br>
  add a1.30h<br>
  mov char.al<br>
  call print_char<br>
  call next_cursor_col umn<br>
  mov flag.0<br>
  fprint32 endp<br>
  main proc<br>
  \.........<br>
  call fprint32 </p>    </td>
  </tr>
</table>
</BODY>
</HTML>

